---
layout: post
title: "[stm32f4]dht11 - 온도 센서 모듈"
description: "[stm32f4]dht11 - 온도 센서 모듈" 
modified: 2016-09-25
tags: [blog]
comments: true
image:
  feature: back6.jpg
---

동적계획식 방법과 분기한정 가지치기 방법으로 0/1 배낭채우기 문제를 해결해보자.
 


<section id="table-of-contents" class="toc">
  <header>
    <h3>Overview</h3>
  </header>
<div id="drawer" markdown="1">
*  Auto generated table of contents
{:toc}
</div>
</section><!-- /#table-of-contents -->



## stm32f4 Discovery

### 소개
<figure>
	<img src="/images/stm32f4.png" alt="">
</figure>

- STM32F4 마이크로프러세서가 장착된 보드이다.
- 기본적으로 가속도센서(LIS302DL or LIS3DSH) MB997B 버전 보드는 LIS302DL를 MB997C 버전 보드는 LIS3DSH를 내장하고 있다.
- 그밖에 Audio DAC, Headphone Jack이 내장되 있다.
- PC와 Uart 통신을 하려면 Uart 모듈이 필요하며 PL2303 을 사용하였다.
 
## DHT11 - 온도 센서 적용하기

### GPIO 구조체
```c
typedef struct
{
  uint32_t GPIO_Pin;              //Specifies the GPIO pins to be configured.

  GPIOMode_TypeDef GPIO_Mode;     //Specifies the operating mode for the selected pins.

  GPIOSpeed_TypeDef GPIO_Speed;   //Specifies the speed for the selected pins.

  GPIOOType_TypeDef GPIO_OType;   //Specifies the operating output type for the selected pins.

  GPIOPuPd_TypeDef GPIO_PuPd;     //Specifies the operating Pull-up/Pull down for the selected pins.

}GPIO_InitTypeDef;

```
- GPIO 구조체는 위와같은 형식으로 되어있다. 
- GPIO_Pin: 사용할 핀을 정해준다.
- GPIO Mode: 위에 기입한 GPIO 핀을 입력으로 할지 출력모드로 할지를 정한다.
- GPIO_Speed: GPIO의 속도를 지정한다 100MHz 50MHz 와 같이 지정가능하다.  
- GPIO_OType: 옵션으로 PP와 OD가 있다.
- GPIO_PuPd: 풀업, 풀다운 저항을 지정하거나 또는 NOPULL 로 지정할 수 있다. 

### GPIO 초기화 하기

```c

	GPIO_InitTypeDef  GPIO_InitStructure;

	//GPIO의 기초적인 정보를 입력하여 초기화
	void dht11_init_output(void)
	{
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);

		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 ;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
		
		//GPIO_init() 함수를 사용하여 지정된 포트와 입력된 구조체를 넘겨 초기화한다.
		GPIO_Init(GPIOD, &GPIO_InitStructure);   
	}

	
	//input으로 변경하기위한 함수
	void dht11_init_input(void)
	{

		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
		GPIO_Init(GPIOD, &GPIO_InitStructure);

	}
	
	
```

- 우선 포트를 제어하기위해 RCC_AHB1PeriphClockCmd(포트 , 활성화 or 비활성화) 함수를 사용한다 RCC_AHB1PeriphClockCmd(GPIOD , ENABLE) 을 입력하여 함수를 호출하면 GPIOD 포트로 클락을 쏴주어서 활성화를 시킨다.
- GPIO 구조체에 정보를입력하고 GPIO_Init() 함수를 사용하여 지정된 포트와 입력된 구조체값을 바탕으로 초기화한다.
- 실제로 모든 핀번호들은 주소값으로 되어있으며 헤더파일에 아래와 같이 선언되어있다. 포트번호역시 마찬가지이다.

```c

#define GPIO_Pin_0                 ((uint16_t)0x0001)  /* Pin 0 selected */
#define GPIO_Pin_1                 ((uint16_t)0x0002)  /* Pin 1 selected */
#define GPIO_Pin_2                 ((uint16_t)0x0004)  /* Pin 2 selected */
#define GPIO_Pin_3                 ((uint16_t)0x0008)  /* Pin 3 selected */
#define GPIO_Pin_4                 ((uint16_t)0x0010)  /* Pin 4 selected */
#define GPIO_Pin_5                 ((uint16_t)0x0020)  /* Pin 5 selected */
#define GPIO_Pin_6                 ((uint16_t)0x0040)  /* Pin 6 selected */
#define GPIO_Pin_7                 ((uint16_t)0x0080)  /* Pin 7 selected */
#define GPIO_Pin_8                 ((uint16_t)0x0100)  /* Pin 8 selected */
#define GPIO_Pin_9                 ((uint16_t)0x0200)  /* Pin 9 selected */
#define GPIO_Pin_10                ((uint16_t)0x0400)  /* Pin 10 selected */
#define GPIO_Pin_11                ((uint16_t)0x0800)  /* Pin 11 selected */
#define GPIO_Pin_12                ((uint16_t)0x1000)  /* Pin 12 selected */
#define GPIO_Pin_13                ((uint16_t)0x2000)  /* Pin 13 selected */
#define GPIO_Pin_14                ((uint16_t)0x4000)  /* Pin 14 selected */
#define GPIO_Pin_15                ((uint16_t)0x8000)  /* Pin 15 selected */
#define GPIO_Pin_All               ((uint16_t)0xFFFF)  /* All pins selected */

``

### 타이머

```c

void timer_init(void)
{
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
	TIM_TimeBaseStructure.TIM_Period = 84000000-1; // 지정한 시간만큼 인터럽트가 발생한다.
	TIM_TimeBaseStructure.TIM_Prescaler = 84-1;		//지정한 시간마다 clock이 발생한다. 
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
	TIM_Cmd(TIM2, ENABLE);
}

``

- 우선 기본적으로 STM32F4 Discovery 는 168MHz MCU 이다. 1초에 168,000,000번 펄스가 발생한다는 말이다. 
- 이 펄스를 ms 나 us 단위로 카운팅을 하고 싶다면 168MHZ에 168,000을 나눠주면 ms로 카운팅 가능하고 168,000,000으로 나눠주면 us로 카운팅 가능하다. 즉 이말은 168,000 번 마다 또는 168,000,000번 마다 카운터를 증가시키라는 의미이다.
- Prescaler에 위 값을 설정해 주면된다. 
- Period는 주기를 설정한다. 


<figure>
	<img src="/images/clock.png" alt="">
</figure>

- stm32f4 칩안에는 여러개의 타이머가 있다 각 Coretex-M4 각 타이머의 bit는 위 표를 참고하자. TIM2와 TIM5는 32bit를 지원한다.
- 타이머도 역시 RCC_APB1PeriphClockCmd() 함수를 사용하여 지정된 주소값을 활성화를 시켜줘야한다.
- 클럭속도에따라 APB1과 APB2 2가지로 나뉘어




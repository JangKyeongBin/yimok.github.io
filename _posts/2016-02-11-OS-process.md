---
layout: post
title: "[OS]Operating System의 발달 과정과 기능"
description: "[OS]Operating System의 발달 과정과 기능" 
modified: 2016-02-12
tags: [blog]
comments: true
image:
  feature: sample-image-4.jpg
---

Operating System이 시기에 따라 어떻게 변화되었고 발전하였는지 알아 보고 Opertating System 이 어떠한 역할을 하는지 알아 보자.

<section id="table-of-contents" class="toc">
  <header>
    <h3>Overview</h3>
  </header>
<div id="drawer" markdown="1">
*  Auto generated table of contents
{:toc}
</div>
</section><!-- /#table-of-contents -->


## 운영체제 발달 과정



## Phase 1 (1950년대)

- 과거에는 컴퓨터 하드웨어의 가격이 굉장히 비쌌지만 인건비는 굉장히 저렴하였다.
다시 말해서 애니악 같은 컴퓨터는 진공관으로 만들어졌고 따로 발전소가 필요 했기때문에 많은 비용이 들어 갔다.
- 초창기에는 OS가 따로 존재 하지 않았고 휴먼 오퍼레이터가 OS 역할을 하였다. 왜냐면 인건비가 저렴 했기때문에 휴먼 오퍼레이터를 사용해도 무리가 없었다.
- 현재 컴퓨터에서 실행하는 프로그램을 과거에는 Job 이라고 불렸는데 이런 Job의 코드 라인들을 어떠한 장치를 통해 카드에 구멍을 뚫어 카드덱으로 보관 하였다.
- 휴먼 오퍼레이터는 사용자로부터 카드덱을 받아서 컴퓨터 시스템에 로딩하고 수행 하여 그 결과를 프린터로 출력하여 사용자에게 전달하는 역할을 하였다.
- 이러한 동작 흐름은 굉장한 단점이 존재하였는데.. 진공관으로 만들어진 컴퓨터라 할지라도 속도는 빨랐다. 그러나 휴먼 오퍼레이터가 중간에 들어가 있어 컴퓨터가 쉬는 시간이 증가하는 단점이 발생하였다.

### Batch Monitor 의 등장

- 앞서 말한 휴먼 오퍼레이터의 단점을 극복하기위해 Batch Monitor 라는 최초의 OS가 등장 하였다. (IBM 1401) 
- 기존에 휴먼 오퍼레이터를 통해 Job을 하나씩 읽어들이는 방식이아니라 메인컴퓨터에 여러개의 Job을 묶어서 수행 하였다. 다시말해서 휴먼 오퍼레이터를 배제시켰다.
- 하지만 Batch Monitor도 문제가 있었는데 CPU가 입출력을 하고 이 입출력이 종료될때까지 CPU가 모니터링을 해야 하는 단점을 가지고 있었다.
- 이러한 단점을 I/O 채널을 개발하여 개선하였다 (CPU 는 I/O 의 시작과 끝만 관심을 가지고 수행한다)

### Synchronization I/O 와 Asynchronization I/O 의 등장

- 동기적 I/O 는 CPU가 어떤 수행을 하다가 I/O를 만났을때 이 I/O의 수행이 종료되어야만 다음 수행을 할 수 있는것을 말한다
- 비동기적 I/O 는 동기적 I/O와는 반대로 CPU가 어떤 수행을 하다가 I/O를 만났을때 그 결과를 기다릴 필요없이 다른 CPU 연산을 수행할 수 있는것을 말한다.
 

### Multiprogramming Batch Monitor 의 등장

- 기존 동기적 I/O를 개선하기 위해 멀티 프로그래밍을 사용하여 컴퓨터 시스템의 메인메모리에 동시에 여러개의 프로그램이 존재하도록 하였다.
- 하지만 이러한 방법은 Memory Protection , Memory Relocation , Concurrent Programming 과 같은 문제점을 발생시켰다.

### Memory Protection

- 멀티 프로그래밍으로 인해 발생된 문제로 당시 기계어로 프로그래밍을 했기 때문에 포인터 에러가 자주 발생 되었다. 이 포인터 에러는 작업을 할 때에 다른 프로그램으로 침범하는 심각한 오류 였다. 프로그램이 아닌 오퍼레이팅 영역을 침범 할 경우 심각한 오류가 발생되어 이러한 형상을 방지해야 할 필요성이 대두되었다. -> 메모리를 보호해야함
- Job 이 사용하는 메인메모리의 시작주소(Base Register에 저장)와 Job이 사용하는 메모리의 크기(Bound Register에 저장)를 사용해 현재 접근하려는 주소 값이 Base Register와 Base Register + Bound Register 사이에 있는지를 확인 -> 즉 범위를 계산하여 메모리 보호를 하였다.

### Memory Relocation

- 멀티 프로그래밍으로 인해 작업이 메인 메모리의 어느 위치에서 로드 될지를 알 수 없기 때문에 임의의 주소에서도 문제없이 수행될 수 있어야 했다.-> Relocation  문제를 하드웨어 메커니즘 개발로 해결하였다. 
- 프로그램을 작성할 때는 항상 0번지에 로드된다고 가정하고 주소값 들을 계산하고, 수행 시에 주소값을 계산하기 위해서는 Base Register의 값을 더해서 실제 물리적 메모리의 주소를 계산 하였다.

<figure>
	<img src="/images/post1-1.PNG" alt="">
</figure>

- CPU에 의해 바로 생성된 주소를 논리적인 주소라 한다. 이 논리적 주소는 MMU를 통해 여러 변환 과정을 겪는다.
- 생성된 논리적 주소는 MMU안에서 Base Register의 값과 더해지고 이 값이 Base Register + Bound Register 의 값과 비교해 작은지	 체크를 한다. -> 만약 이 값을 넘어설 경우 다른 메모리 영역을 건드린다는 뜻이기 때문이다.
- 이러한 과정을 최종적으로 거친 주소를 물리적 주소라 한다.

## Phase 2 (1960년대 ~ 1990년대)

- 하드웨어 기술이 발달되 가격이 싸졌으나 인건비는 상승되었다. Phase 1에서는 OS 역할이 CPU가 idle 하지 않게 만드는 것이 목표 였다면 phase 2 에서는 어떻게 하면 사람들의 생산성을 향상 시킬 수 있을까? 하는 것이 목표가 되었다. -> 터미널이 개발 되 각사용자에게 터미널을 제공해주고 터미널들은 하나의 서버(CPU)에 연결 되었다.
- 하나의 서버에서 여러 사용자가 접근했기 때문에 문제점이 발생되었고 이러한 문제점을 해결하기 위해 CPU의 시간을 여러 사람들에게 쪼개어 제공하는 (Time sharing) 시스템이 개발됨
- Time sharing 시스템 으르 인해 컴퓨터와 사용자가 서로 대화 하는것처럼 느끼게 되었다.

## Phase 3 (1990년대 ~ 현재)

- 인터넷이 선택이아니라 필수가 되었고 모든 컴퓨터가 네트워킹으로 연결 되어 있다. 요즘 PC는 TCP/IP가 탑재되어 나옴
- PC os와 Server os의 경계가 사라졌다. (하드웨어의 가격이 매우 싸져 pc의 프로세서 성능이 상승되었기 때문에) -> os가 복잡해짐
- 멀티미디어 서포트가 상승되었다. (과거에는 텍스트만 처리하면 되었다 다운로드 한번으로 처리됨) -> 오디오, 동영상과 같은 미디어들을 처리해야할 필요성이 생겼다. (Continuos Media: 계속적으로 처리해야함)
- 이러한 멀티미디어 발전으로 운영체제의 스케줄링 방식의 변화가 생겼다. 중요한 일을 먼저 처리하는 우선순위 기반 스케줄링에서 -> Continuos Media를 원활하게 처리하기 위한 Bandwidth 스케줄링으로 변화

### Downloading 과 Streaming 의 차이 
- Downloading 은 전체데이터를 확보한 다음에 작업을 시작 할 수 있고 Streaming은 일부의 데이터만 확보한 상태에서 작업을 시작할 수 있음


## 발전단계 정리

- OS는 하드웨어의 Utilization을 높이기 위해 등장하였다. 초창기 휴먼 오퍼레이터를 대체 하기 위해 Batch Monitor 가 등장하였고 여기서 좀더 CPU의 활용을 높이기 위해 I/O와 CPU를 오버랩 시키기 위한 OS가 나왔다. 하지만 동기화 문제가 해결되지 않아서 멀티 프로그래밍이 나왔고 멀티 프로그래밍으로 인한 Memory Protection, Memory Relocation 단점을 보완하기 위한 기술이 발전되 었다.
- 무어의 법칙에 따라 하드웨어의 기술이 발전하여 가격이 싸졌으나 반면에 인건비는 상승되었다 이에 따라 "어떻게 하면 사람들의 생산성을 향상 시킬 수 있을까?" 하는 것이 목표가 되었다. -> 터미널이 개발 되 각 사용자에게 터미널을 제공해주고 터미널들은 하나의 서버(CPU)에 연결 되어서 하나의 서버에 여러명의 사용자가 접근하여 이용가능하도록 만들었다. 
- 하지만 다수의 사용자가 접근했기 때문에 문제점이 발생되었고 이러한 문제점을 해결하기 위해 CPU의 시간을 여러 사람에게 쪼개어 제공하는 (Time Sharing) 시스템이 개발 되었다. 
- Time Sharing 시스템으로 사용자는 컴퓨터와 서로 대화하는 것처럼 느끼게 되었고 컴퓨터가 자신의 것이라고 생각하게 되어 중요한 개인파일들을 올리게 되었다. 이러한 문제를 해결하기 위해 안전한 파일 시스템이 개발되었다.

## OS의 기능

<figure>
	<img src="/images/post1-2.PNG" alt="">
</figure>

### Coordinator(조정자) 입장에서 본 OS의 기능

OS가 중재자로서 여러 Task 들이 자원들을 효율적으로 사용할 수 있도록 도와줌
>- 컴퓨터 입장에서 볼 떄 Network System 은 I/O System의 하나로 볼 수 있다. 또 File System 역시 하드디스크에 저장되어있어 I/O System 기능의 하나로 볼 수 있다. 하지만 왜 따로 분류를 해놨을까?
>- 만약 하나로 되어있다면..  나는 지금 네트워크를 처리해야하는데 하드디스크 입출력 때문에 막혀 진행하지 못하는 상황이 발생 될 수 있다. 

### UNIX OS 에서의 I/O 분류

대표적인 OS UNIX System 에서는 각 I/O를 속도차이, 데이터 차이에 따라 별도로 분류 해놓았다.

- Character I/O device : I/O 단위가 Byte인 장치(예: 키보드, 마우스 -> I/O 시스템)
- Block I/O device : I/O 단위가 Block인 장치(예: 하드디스크 -> 파일시스템)
- Network I/O device : 네트워크를 제어하는 장치(예: 소켓 -> 네트워크시스템)

### illusion Generator 입장에서 본 OS의 기능

- 사용자들이 하드웨어의 모든 구조를 알 필요 없이 OS가 그러한 기능 들을 서포트 해준다.
- Time sharing, 가상메모리 기술들을 제공
- 단점: Time-sharing 시스템에서의 Thrashing 발생 -> 사용자의 수가 어떤 임계점을 넘어서는 순간 응답시간이 급격히 증가하는 현상이 발생
 
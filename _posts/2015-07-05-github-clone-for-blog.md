---
layout: post
title: Github 블로그 repository를 clone해서 글쓰기
description: 블로그 repository가 설치되어 있지 않은 PC에서 블로그를 작성하는 방법
modified: 2015-07-05
tags: [blog]
comments: true
image:
  feature: abstract-4.png
  credit: dargadgetz
---

블로그 repository가 설치되어 있지 않은 PC에서 블로그를 작성하는 방법을 알아보자. 
여러가지 방법이 있겠지만, 이번에는 github의 remote repository를 clone해서 글을 작성하고 commit하는 방법을 살펴보기로 한다. 

<section id="table-of-contents" class="toc">
  <header>
    <h3>Overview</h3>
  </header>
<div id="drawer" markdown="1">
*  Auto generated table of contents
{:toc}
</div>
</section><!-- /#table-of-contents -->

## 운영체제 발달 과정



## Phase 1 (1950년대)

- 과거에는 컴퓨터 하드웨어의 가격이 굉장히 비쌌지만 인건비는 굉장히 저렴하였다.
다시 말해서 애니악 같은 컴퓨터는 진공관으로 만들어졌고 따로 발전소가 필요 했기때문에 많은 비용이 들어 갔다.
- 초창기에는 OS가 따로 존재 하지 않았고 휴먼 오퍼레이터가 OS 역할을 하였다. 왜냐면 인건비가 저렴 했기때문에 휴먼 오퍼레이터를 사용해도 무리가 없었다.
- 현재 컴퓨터에서 실행하는 프로그램을 과거에는 Job 이라고 불렸는데 이런 Job의 코드 라인들을 어떠한 장치를 통해 카드에 구멍을 뚫어 카드덱으로 보관 하였다.
- 휴먼 오퍼레이터는 사용자로부터 카드덱을 받아서 컴퓨터 시스템에 로딩하고 수행 하여 그 결과를 프린터로 출력하여 사용자에게 전달하는 역할을 하였다.
- 이러한 동작 흐름은 굉장한 단점이 존재하였는데.. 진공관으로 만들어진 컴퓨터라 할지라도 속도는 빨랐다. 그러나 휴먼 오퍼레이터가 중간에 들어가 있어 컴퓨터가 쉬는 시간이 증가하는 단점이 발생하였다.

### Batch Monitor 의 등장

- 앞서 말한 휴먼 오퍼레이터의 단점을 극복하기위해 Batch Monitor 라는 최초의 OS가 등장 하였다. (IBM 1401) 
- 기존에 휴먼 오퍼레이터를 통해 Job을 하나씩 읽어들이는 방식이아니라 메인컴퓨터에 여러개의 Job을 묶어서 수행 하였다. 다시말해서 휴먼 오퍼레이터를 배제시켰다.
- 하지만 Batch Monitor도 문제가 있었는데 CPU가 입출력을 하고 이 입출력이 종료될때까지 CPU가 모니터링을 해야 하는 단점을 가지고 있었다.
- 이러한 단점을 I/O 채널을 개발하여 개선하였다 (CPU 는 I/O 의 시작과 끝만 관심을 가지고 수행한다)

### Synchronization I/O 와 Asynchronization I/O 의 등장

- 동기적 I/O 는 CPU가 어떤 수행을 하다가 I/O를 만났을때 이 I/O의 수행이 종료되어야만 다음 수행을 할 수 있는것을 말한다
- 비동기적 I/O 는 동기적 I/O와는 반대로 CPU가 어떤 수행을 하다가 I/O를 만났을때 그 결과를 기다릴 필요없이 다른 CPU 연산을 수행할 수 있는것을 말한다.
 

### Multiprogramming Batch Monitor 의 등장

- 기존 동기적 I/O를 개선하기 위해 멀티 프로그래밍을 사용하여 컴퓨터 시스템의 메인메모리에 동시에 여러개의 프로그램이 존재하도록 하였다.
- 하지만 이러한 방법은 Memory Protection , Memory Relocation , Concurrent Programming 과 같은 문제점을 발생시켰다.

### Memory Protection

- 멀티 프로그래밍으로 인해 발생된 문제로 당시 기계어로 프로그래밍을 했기 때문에 포인터 에러가 자주 발생 되었다. 이 포인터 에러는 작업을 할 때에 다른 프로그램으로 침범하는 심각한 오류 였다. 프로그램이 아닌 오퍼레이팅 영역을 침범 할 경우 심각한 오류가 발생되어 이러한 형상을 방지해야 할 필요성이 대두되었다. -> 메모리를 보호해야함
- Job 이 사용하는 메인메모리의 시작주소(Base Register에 저장)와 Job이 사용하는 메모리의 크기(Bound Register에 저장)를 사용해 현재 접근하려는 주소 값이 Base Register와 Base Register + Bound Register 사이에 있는지를 확인 -> 즉 범위를 계산하여 메모리 보호를 하였다.

### Memory Relocation

- 멀티 프로그래밍으로 인해 작업이 메인 메모리의 어느 위치에서 로드 될지를 알 수 없기 때문에 임의의 주소에서도 문제없이 수행될 수 있어야 했다.-> Relocation  문제를 하드웨어 메커니즘 개발로 해결하였다. 
- 프로그램을 작성할 때는 항상 0번지에 로드된다고 가정하고 주소값 들을 계산하고, 수행 시에 주소값을 계산하기 위해서는 Base Register의 값을 더해서 실제 물리적 메모리의 주소를 계산 하였다.

<figure>
	<img src="/images/post1-1.PNG" alt="">
</figure>

- CPU에 의해 바로 생성된 주소를 논리적인 주소라 한다. 이 논리적 주소는 MMU를 통해 여러 변환 과정을 겪는는다.
- 생성된 논리적 주소는 MMU안에서 Base Register의 값과 더해지고 이 값이 Base Register + Bound Register 의 값과 비교해 작은지	 체크를 한다. -> 만약 이 값을 넘어설 경우 다른 메모리 영역을 건드린다는 뜻이기 때문이다.
- 이러한 과정을 최종적으로 거친 주소를 물리적 주소라 한다.

## Phase 2 (1960년대 ~ 1990년대)

- 하드웨어 기술이 발달되 가격이 싸졌으나 인건비는 상승되었다. Phase 1에서는 OS 역할이 CPU가 idle 하지 않게 만드는 것이 목표 였다면 phase 2 에서는 어떻게 하면 사람들의 생산성을 향상 시킬 수 있을까? 하는 것이 목표가 되었다. -> 터미널이 개발 되 각사용자에게 터미널을 제공해주고 터미널들은 하나의 서버(CPU)에 연결 되었다.
- 하나의 서버에서 여러 사용자가 접근했기 때문에 문제점이 발생되었고 이러한 문제점을 해결하기 위해 CPU의 시간을 여러 사람들에게 쪼개어 제공하는 (Time sharing) 시스템이 개발됨
- Time sharing 시스템 으르 인해 컴퓨터와 사용자가 서로 대화 하는것처럼 느끼게 되었다.

## Phase 3 (1990년대 ~ 현재)

- 인터넷이 선택이아니라 필수가 되었고 모든 컴퓨터가 네트워킹으로 연결 되어 있다. 요즘 PC는 TCP/IP가 탑재되어 나옴
- PC os와 Server os의 경계가 사라졌다. (하드웨어의 가격이 매우 싸져 pc의 프로세서 성능이 상승되었기 때문에) -> os가 복잡해짐
- 멀티미디어 서포트가 상승되었다. ( 과거에는 텍스트만 처리하면 되었다 다운로드 한번으로 처리됨 ) -> 오디오, 동영상과 같은 미디어들을 처리해야할 필요성이 생겼다. (Continuos Media: 계속적으로 처리해야함)
- 이러한 멀티미디어 발전으로 운영체제의 스케줄링 방식의 변화가 생겼다. 중요한 일을 먼저 처리하는 우선순위 기반 스케줄링에서 -> Continuos Media를 원활하게 처리하기 위한 Bandwidth 스케줄링으로 변화

### Downloading 과 Streaming 의 차이 
- Downloading 은 전체데이터를 확보한 다음에 작업을 시작 할 수 있고 Streaming은 일부의 데이터만 확보한 상태에서 작업을 시작할 수 있음
